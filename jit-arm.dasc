/* JIT for Brainf*ck */

#include <stdint.h>
#include "util.h"

|.arch arm
|.actionlist actions
|
|// Use r4 as our cell pointer.
|// Since r4 is a callee-save register, it will be preserved
|// across our calls to getchar and putchar.
|.define PTR, r4
|
|// Macro for calling a function.
|// In cases where our target is <=2**32 away we can use
|//   | call &addr
|// But since we don't know if it will be, we use this safe
|// sequence instead.
|.macro callp, addr
|  mov r6, #(uintptr_t)addr
|  blx r6
|.endmacro

#define Dst &state
#define MAX_NESTING 256

int main(int argc, char *argv[]) {
  if (argc < 2) err("Usage: jit-arm <inputfile>");
  dasm_State *state;
  initjit(&state, actions);

  unsigned int maxpc = 0;
  int pcstack[MAX_NESTING];
  int *top = pcstack, *limit = pcstack + MAX_NESTING;

  printf("limit = %d, top = %d, maxpc = %d\n", *limit, *top, maxpc);

  // Function prologue.
  | push {PTR, r5, lr}
  | mov PTR, r0

  for (char *p = read_file(argv[1]); *p; p++) {
  }

  // Function epilogue.
  |  pop {PTR, r5, pc}
  |  bx lr

  void (*fptr)(char*) = jitcode(&state);
  char *mem = calloc(30000, 1);
#if defined(__GNUC__)
  __builtin___clear_cache((char*) mem, (char*) (mem + sizeof(char) * 30000));
#else
#error "Missing builtin to flush instruction cache"
#endif
  fptr(mem);
  free(mem);
  free_jitcode(fptr);
  return 0;
}
